package grid

import (
	"sync"

	"github.com/diakovliev/2rooms-oak/packages/common"
	"github.com/diakovliev/2rooms-oak/packages/layout2d"
	"github.com/oakmound/oak/v4/alg/floatgeom"
	"github.com/oakmound/oak/v4/event"
	oakscene "github.com/oakmound/oak/v4/scene"
)

// Grid is a grid
type Grid struct {
	*sync.Mutex
	cid       event.CallerID
	rows      []Row
	pos       floatgeom.Point2
	speed     floatgeom.Point2
	alignment layout2d.Alignment
	w, h      float64
	margin    float64
}

// New returns a new Grid instance.
//
// Parameters:
//   - pos: the position of the Grid.
//   - margin: the margin of the Grid.
//
// Returns:
//   - *Grid: a pointer to the created Grid instance.
func New(
	ctx *oakscene.Context,
	pos floatgeom.Point2,
	speed floatgeom.Point2,
	margin float64,
) (ret *Grid) {
	ret = &Grid{
		Mutex:     &sync.Mutex{},
		pos:       pos,
		speed:     speed,
		margin:    margin,
		alignment: layout2d.Left | layout2d.Top,
		w:         margin,
		h:         margin,
		rows:      []Row{},
	}
	ret.cid = ctx.CallerMap.Register(ret)
	return
}

// update updates the dimensions of the Grid.
//
// It iterates over the entities in the Grid and updates the width and height
// based on the maximum width of the columns and the maximum height of the rows.
// The width and height are stored in the Grid's w and h fields respectively.
func (g *Grid) update() {
	g.w = 2 * g.margin
	g.h = 2 * g.margin
	for i := 0; i < len(g.rows); i++ {
		for j := 0; j < len(g.rows[i].entities); j++ {
			if g.h < g.Column(j).H() {
				g.h = g.Column(j).H()
			}
		}
		if g.w < g.Row(i).W() {
			g.w = g.Row(i).W()
		}
	}
}

// Init creates a new Grid with the specified number of rows and columns, and initializes it with entities
// generated by the provided provider function. The Grid is returned as a pointer.
//
// Parameters:
// - rows: the number of rows in the Grid
// - cols: the number of columns in the Grid
// - provider: a function that generates entities for each cell in the Grid, based on the row and column index
//
// Return:
// - *Grid: a pointer to the newly created Grid
func (g *Grid) Init(rows, cols int, provider func(row, col int) common.Entity) *Grid {
	g.Mutex = &sync.Mutex{}
	g.rows = make([]Row, rows)
	for i := 0; i < rows; i++ {
		g.rows[i] = Row{g, make([]common.Entity, cols)}
		for j := 0; j < cols; j++ {
			if provider == nil {
				g.rows[i].entities[j] = nil
			} else {
				g.rows[i].entities[j] = provider(i, j)
			}
		}
	}
	g.update()
	return g
}

// Set sets the given entity at the specified row and column in the Grid.
//
// Parameters:
// - row: the row index in the Grid where the entity will be set.
// - col: the column index in the Grid where the entity will be set.
// - entity: the entity to be set in the Grid.
//
// Return:
// - *Grid: the modified Grid.
func (g *Grid) Set(row, col int, entity common.Entity) *Grid {
	g.Lock()
	defer g.Unlock()
	g.rows[row].entities[col] = entity
	g.update()
	return g
}

// Get returns the layout2d.Entity at the specified row and column indices in the Grid.
//
// Parameters:
// - row: The row index of the desired entity.
// - col: The column index of the desired entity.
//
// Returns:
// - layout2d.Entity: The entity located at the specified row and column indices.
func (g Grid) Get(row, col int) common.Entity {
	g.Lock()
	defer g.Unlock()
	return g.rows[row].entities[col]
}

// Row returns a Row object representing the entities in the grid at the specified index.
//
// Parameters:
//   - index: The index of the row.
//
// Returns:
//   - Row: A Row object containing the entities at the specified index.
func (g *Grid) Row(index int) Row {
	// g.Lock()
	// defer g.Unlock()
	if index >= len(g.rows) {
		return Row{g, []common.Entity{}}
	}
	return Row{g, g.rows[index].entities}
}

// Column returns the column at the specified index in the Grid.
//
// The index parameter specifies the index of the column to retrieve.
// The function returns a Column object representing the column at the given index.
func (g *Grid) Column(index int) Column {
	// g.Lock()
	// defer g.Unlock()
	column := make([]common.Entity, 0, len(g.rows))
	for _, row := range g.rows {
		if index >= len(row.entities) {
			column = append(column, nil)
		} else {
			column = append(column, row.entities[index])
		}
	}
	return Column{g, column}
}

func (g Grid) CID() event.CallerID {
	return event.Global
}

// Dims returns the dimensions of the Grid as a floatgeom.Point2.
//
// There are no parameters.
// It returns a floatgeom.Point2.
func (g Grid) Dims() floatgeom.Point2 {
	return floatgeom.Point2{g.w, g.h}
}

// X returns the X-coordinate of the Grid object.
//
// No parameters.
// Returns a float64 value.
func (g Grid) X() float64 {
	return g.pos.X()
}

// Y returns the Y coordinate of the grid.
//
// No parameters.
// Returns a float64.
func (g Grid) Y() float64 {
	return g.pos.Y()
}

// W returns the value of the W field in the Grid struct.
//
// No parameters.
// Returns a float64.
func (g Grid) W() float64 {
	return g.w
}

// H returns the value of the 'h' field in the Grid struct.
//
// No parameters.
// Returns a float64.
func (g Grid) H() float64 {
	return g.h
}

// SetPos sets the position of the Grid to the specified point.
//
// p: The new position for the Grid.
func (g *Grid) SetPos(p floatgeom.Point2) {
	g.Lock()
	g.pos = p
	g.apply(g.alignment)
}

// vectors calculates the vectors of the Grid based on the given alignment.
//
// The alignment parameter specifies the layout alignment.
// The return type is a slice of layout2d.Vectors.
func (g Grid) vectors(alignment layout2d.Alignment) (ret []common.Vector) {
	if len(g.rows) == 0 {
		return
	}
	columnWiths := make([]float64, len(g.rows))
	for i := 0; i < len(g.rows[0].entities); i++ {
		columnWiths[i] = g.Column(i).W()
	}
	top := g.pos.Y() + g.margin
	for _, row := range g.rows {
		rh := row.H()
		left := g.pos.X() + g.margin
		for j, entity := range row.entities {
			cw := columnWiths[j]
			if entity == nil {
				left += g.margin
				continue
			}
			w := entity.W()
			h := entity.H()
			oldPos := floatgeom.Point2{entity.X(), entity.Y()}
			newX := oldPos.X()
			newY := oldPos.Y()
			if alignment&layout2d.Left|layout2d.Right|layout2d.HCenter != 0 {
				switch {
				case alignment&layout2d.Left == layout2d.Left:
					newX = left
				case alignment&layout2d.HCenter == layout2d.HCenter:
					newX = left + cw/2 - w/2
				case alignment&layout2d.Right == layout2d.Right:
					newX = left + cw - w
				}
			}
			if g.alignment&layout2d.Top|layout2d.Bottom|layout2d.VCenter != 0 {
				switch {
				case alignment&layout2d.Top == layout2d.Top:
					newY = top
				case alignment&layout2d.VCenter == layout2d.VCenter:
					newY = top + rh/2 - h/2
				case alignment&layout2d.Bottom == layout2d.Bottom:
					newY = top + rh - h
				}
			}
			newPos := floatgeom.Point2{newX, newY}
			ret = append(ret, common.Vector{
				Entity: entity,
				Delta:  newPos.Sub(oldPos),
				Old:    oldPos,
				New:    newPos,
				// TODO: get entity speed
				Speed: g.speed,
			})
			left += cw + g.margin
		}
		top += rh + g.margin
	}
	return
}

// Vectors returns the vectors of the Grid based on the given alignment.
//
// alignment: the alignment of the vectors.
// []layout2d.Vectors: the vectors of the Grid.
func (g *Grid) Vectors(alignment layout2d.Alignment) []common.Vector {
	g.Lock()
	defer g.Unlock()
	g.alignment = alignment
	return g.vectors(alignment)
}

func (g *Grid) apply(alignment layout2d.Alignment) {
	g.alignment = alignment
	for _, vector := range g.vectors(alignment) {
		vector.Entity.SetPos(vector.New)
	}
}

// Apply applies the given alignment to the Grid.
//
// alignment: the alignment to be applied to the Grid.
func (g *Grid) Apply(alignment layout2d.Alignment) {
	g.Lock()
	defer g.Unlock()
	g.apply(alignment)
}
